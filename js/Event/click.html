<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no">
    <title>script</title>
  </head>
  <body>
    你好javascript
    <!-- <button type="button" onclick="say(event, this)">点我</button> -->
    <button id="btn" type="button">点我</button>
    <div id="result">结果:</div>
    <script>
      /* 
      以下说明都是以click事件为例
      默认元素.onclick是null

      1、在HTML中绑定事件，会先给元素onclick一个空的函数，然后再在空函数里面执行所绑定的代码，例如：
      <button type="button" onclick="say(event, this)">点我</button>
      在打印元素.onclick的结果是：
      function() {
        say(event, this)
      }

      2、在JS中通过onclick = 形式绑定事件，会直接把方法赋值给元素.onclick
      3、在JS中通过addEventListener形式绑定事件，元素.onclick依然是null，因为元素.onclick和addEventListener是相互独立的
      在一个元素中，如果既有元素.onclick绑定，也有addEventListener绑定，那么这些方法都会被执行
      */
      function say(e, content) {
        console.log(e)
        console.log(this)// this是window对象
        console.log(content.onclick)// content是触发事件的元素
        document.getElementById('result').innerHTML = '结果：你点了我'
      }

      const buttonEl = document.getElementById('btn')
      console.log(buttonEl.onclick)

      buttonEl.onclick = clickBtn

      function clickBtn() {
        console.log('你点击了按钮')
      }

      console.log(buttonEl.onclick)

      buttonEl.addEventListener('click', function() {
        console.log('buttonEl----fun1')
      })
      buttonEl.addEventListener('click', function() {
        console.log('buttonEl----fun2')
      })
      buttonEl.addEventListener('click', function() {
        console.log('buttonEl----fun3')
      })

      console.log(buttonEl.onclick)
    </script>
  </body>
</html>